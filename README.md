# Journey Builder UI Coding Challenge

This project is a solution to the Avantos Journey Builder React Coding Challenge.
It implements a node-based UI for visualizing a DAG of forms and configuring prefill data between them.

## Running Locally


## Project Structure

-   `src/components`: React components for different parts of the UI.
    -   `PrefillPanel`: Displays prefill configuration for a selected form node.
    -   `PrefillSourceModal`: Modal for selecting a data source to prefill a field.
-   `src/services`:
    -   `api.ts`: Fetches graph data from the mock server.
    -   `prefillSources.ts`: Contains logic for identifying available prefill data sources (direct, transitive, global) and is designed for extensibility.
    -   `graphUtils.ts` (Conceptual, parts are in `prefillSources.ts`): Utilities for graph traversal (e.g., finding upstream nodes).
-   `src/types`: TypeScript type definitions.
    -   `graph.ts`: Types for graph nodes, edges, fields, and API responses.
    -   `prefill.ts`: Types for prefill configurations and options.
-   `src/styles`: CSS files.
    -   `global.css`: Global styles and React Flow base styles.
-   `src/App.tsx`: Main application component, sets up React Flow, manages state.
-   `src/main.tsx`: Entry point of the React application.

## Extensibility: Adding New Data Sources

The system for providing prefill data sources is designed to be extensible, primarily through the `src/services/prefillSources.ts` file.

To add a new data source:

1.  **Define a Provider Function**: Create a new function within `prefillSources.ts` (or a new module if it's complex) that has a signature similar to `getDirectDependencyOptions`, `getTransitiveDependencyOptions`, or `getGlobalDataOptions`:
    ```typescript
    const getNewDataSourceOptions = (
      targetNode: AppNode,
      targetField: FormField,
      allNodes: AppNode[],
      allEdges: AppEdge[]
      // Potentially other context or services if needed
    ): PrefillOption[] => {
      const options: PrefillOption[] = [];
      // ... logic to find and create PrefillOption objects ...
      // Example:
      // options.push({
      //   id: 'newSource.someIdentifier',
      //   label: 'New Source - Some Value',
      //   sourceNodeId: 'newSourceSystem', // Or relevant node ID
      //   sourceFieldId: 'someIdentifier',
      //   sourceType: 'custom', // Or 'form', 'global'
      //   meta: { /* any relevant metadata for UI grouping */ }
      // });
      return options;
    };
    ```
2.  **Register the Provider**: Add your new provider function to the `dataSourceProviders` array within the `getAvailablePrefillOptions` function in `prefillSources.ts`:
    ```typescript
    export const getAvailablePrefillOptions = (...) => {
      // ...
      const dataSourceProviders = [
        getDirectDependencyOptions,
        getTransitiveDependencyOptions,
        getGlobalDataOptions,
        getNewDataSourceOptions, // <--- Add your new provider here
      ];
      // ...
    };
    ```

3.  **Update UI (If Needed)**: If your new data source requires specific categorization in the `PrefillSourceModal.tsx`, you might need to adjust the filtering logic there or add a new section, potentially by adding a unique `meta` property to your `PrefillOption` objects generated by your provider.

The `PrefillOption` type in `src/types/prefill.ts` can also be extended if your new data source requires additional metadata.

## Patterns and Considerations

-   **Component Composition**: The UI is broken down into smaller, manageable components.
-   **Type Safety**: TypeScript is used throughout for better maintainability and to catch errors early.
-   **State Management**: Primary state (nodes, edges, selected node, prefill configurations) is managed in `App.tsx` using React's `useState` and `useCallback`. For a larger application, a dedicated state management library (like Zustand or Redux Toolkit) or React Context might be more suitable for parts of the state.
-   **React Flow**: Leverages the `reactflow` library for graph visualization and interaction.
-   **Extensible Data Sources**: The core logic for determining prefill options is centralized and designed to be easily extended (see above).
-   **Basic Layout**: A very simple grid-based layout is used for initial node positioning. For more complex graphs, integrating a layout engine like Dagre or ELK JS with React Flow would be beneficial.

## Testing (Evaluation Criteria)

The challenge asks: "Does the project have good tests?"

This solution provides the structure for testing but does not include comprehensive tests due to time constraints for this auto-generated solution. To add tests:

1.  **Setup**: Vite uses Vitest for unit testing. You can install it if not already part of the template (`npm install -D vitest @testing-library/react @testing-library/jest-dom jsdom`).
2.  **Unit Tests**: Key areas for unit tests would be:
    -   `src/services/api.ts`: Mocking `fetch` to test API call success and error handling.
    -   `src/services/prefillSources.ts`:
        -   Graph traversal utilities (`getUpstreamNodeIds`, `getTransitiveUpstreamNodeIds`).
        -   Individual data source provider functions (`getDirectDependencyOptions`, etc.) with mock graph data.
        -   The main `getAvailablePrefillOptions` orchestrator.
    -   `src/App.tsx`: Test data transformation logic (`transformApiDataToFlow`).
3.  **Component Tests**: Using `@testing-library/react` to test:
    -   Rendering of `PrefillPanel` and `PrefillSourceModal` with different props.
    -   User interactions like clicking buttons, selecting options.

**Example Test File Structure (e.g., `src/services/prefillSources.test.ts`):**

```typescript
import { describe, it, expect } from 'vitest';
import { getDirectDependencyOptions } from './prefillSources';
import type { AppNode, AppEdge, FormField } from '../types/graph';
import type { PrefillOption } from '../types/prefill';

// Mock data for tests
const mockNodes: AppNode[] = [
  { id: 'A', data: { label: 'Form A', fields: [{id: 'a1', name: 'Field A1', type: 'text'}] }, position: {x:0, y:0} },
  { id: 'B', data: { label: 'Form B', fields: [{id: 'b1', name: 'Field B1', type: 'text'}] }, position: {x:0, y:0} },
];
const mockEdges: AppEdge[] = [{ id: 'eA-B', source: 'A', target: 'B' }];
const mockTargetNode: AppNode = mockNodes[1]; // Form B
const mockTargetField: FormField = mockTargetNode.data.fields[0];

describe('Prefill Source Logic', () => {
  it('getDirectDependencyOptions should find fields from direct upstream nodes', () => {
    const options = getDirectDependencyOptions(mockTargetNode, mockTargetField, mockNodes, mockEdges);
    expect(options.length).toBe(1);
    expect(options[0].sourceNodeId).toBe('A');
    expect(options[0].sourceFieldId).toBe('a1');
  });
});
```

This provides a starting point for building out a robust test suite.
